<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue 2 基础学习 </title>
    <!-- 样式文件 -->
    <link rel="stylesheet" href="/vuejs-playlist/style.css">
    <!-- vue2 文件引入 -->
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>

    <!-- axiios文件引入 类似ajax -->
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>

</head>

<body>

        <!-- 最大的问题就是后端数据发过来什么样子结构不知道，导致的，
    后面的题目全部重新问一下后端数据应该是什么样子的 -->



    <!-- a1学习 传输值 返回值 -->
    <!-- <div id="vue-app">
        <h1>{{greet(' afernoon') }}</h1>
        <p>Name:{{name}}</p>
        <p>job:{{job}}</p>
    </div> -->


    <!-- a2学习  绑定数据-->
    <!-- <div id="vue-app">
        <h1>{{greet(' afernoon') }}</h1>
        <p>Name:{{name}}</p>
        <a v-bind:href="website"> The ner ninja 忍者  </a>
        <input type="text" v-bind:value="name">
        <input type="text" v-bind:value="job">
        <p v-html="websiteTag"></p>
    </div> -->




        




    <!-- a4 双向绑定 -->
    <!-- <div id="vue-app">
        <h1>Key board Events 键盘事件</h1>
        <label>Name:</label>
        <span>{{name}}</span>
        <input type="text" v-model="name"> 
        <label>Age:</label>
        <input type="text" v-model="age" >
        <span>{{age}}</span>
    </div> -->
    <!-- {{span}} 的值，不在视图实例中 -->
    <!-- 需求 用户输入内容时候 span更新用户输入内容 -->
    <!-- v-model="name" 检查是否参与实例 ，并且更新实例中字段值，然后{{name}} 拿到新节点 更新 -->



    <!-- a5 属性计算 -->
    <!-- 任何复杂逻辑，你都应当使用计算属性  -->
    <!-- <div id="vue-app">
        <h1>Computed properties 计算属性 </h1>
        <button v-on:click="a++">Add to </button>
        <button v-on:click="b++" >Add to B </button>
        <p>-{{a}}</p>
        <p>-{{b}}</p>

        <p>Age + A = {{addToA}} </p>
        <p>Age + B = {{addToB}} </p>
    </div> -->
    <!--两个不同的方法 addta addtb，执行a， 从上到下执行所有， 执行b 也是同样，虽然b方法返回值执未执行 ，但是打印方法执行  -->
    <!-- ，每当触发重新渲染时， 调用方法methods 将总会再次执行函数。 -->

    <!--需求实现 ： 20岁 调用 a值 输出  -->
    <!-- 重点 渲染函数中设定字段和值 ，模板使用字段 ，如果模板字段值在模板中发生计算变化，渲染函数中字段值也会同步变化   -->
    <!-- 点击事件产生值 后面在调用点击事件产生的a值 进行输出 -->
    
    <!-- 
        模板内计算问题
        <p>-{{a}}</p>
        <p>-{{b}}</p>
        赋值逻辑问题 模板中计算字段 a++ 在前， -a在后， -a会覆盖前面的+ 
    -->


    


















    <!-- b1 即时修改-->
        <!-- 控制台修改 vm.greet = '一起帮' -->
    <!-- <h1 id="yz-hello"> 
        {{greet}} 
    </h1> -->


    <!-- b2 禁止变化 最初加载时绑定一次-->
    <!--v-once -->
    <!-- v-on:click.once="add(1)" -->
    <!-- <h1 v-once  id="yz-hello"> 
        {{greet}} 
    </h1> -->


    <!-- b3 js表达式 -->
    <!--在花括号中的使用 运算  调用方法的叫js 表达式  -->
    <!-- 资料 -->
    <!-- <button v-on:click="age++">Add 加一岁 </button>
    <p>Age + A = {{addToA}} </p>  调用计算属性的addtoA方法 -->
    <!-- <h1>{{greet(' afernoon') }}</h1> -->
    <!-- b3 -->
    <!-- <h1 v-once  id="yz-hello"> {{greet.substring(1)}} </h1>   -->


    <!-- b4 属性绑定 titl属性-->
        <!-- 参考资料 -->
    <!-- <a v-bind:href="website"> The ner ninja 忍者 href属性绑定 </a>
    <input type="text" v-bind:value="name"> vlue 属性绑定 -->
    <!-- <h1 v-bind:title="who + '1' "  id="yz-hello">飞哥 属性使用js表达式 + </h1> -->
    


    <!-- b5 绑定true值 于 flase值 -->
    <!-- 结论 该属性直接不予显示  -->





















    <!-- b6 属性绑定   动态参数 -->
        <!-- 参考资料 -->
    <!-- <h1 v-bind:title="who + '1' "  id="yz-hello">飞哥 属性使用js表达式 + </h1> -->
    <!-- 上面title是写死的 who是活的 重命名的 在渲染函数里面 -->
    <!-- b6内容 -->
    <!-- <h1 v-bind:[attr]="who" id="yz-hello">{{greet}}</h1> -->
    <!-- 上面attr是活的 重命名的 在渲染函数里面 ,当成变量用 里面存着title属性,who也是活的  -->

    
      <!-- class绑定 -->
    <!-- b7 class 样式类 绑定 数组绑定法 -->
    <!-- <h1 id="yz-hello" v-bind:class="[bg,fs]">hello，源栈</h1> -->
    <!-- <h1 id="yz-hello" v-bind:class="['bg','fs']">hello，源栈</h1> -->
    <!-- 注意 数组名字:不加单引号是指向data区的 加了就放弃data区域指向 -->

   <!-- 不用数组 用名字绑定 -->
    <!-- <h1 id="yz-hello" v-bind:class="bg">hello，源栈</h1> --> 
  
    <!-- 存入数据区，调用 -->
  <!-- <h1 id="yz-hello" v-bind:class="getclass()">hello，源栈</h1> -->


    <!-- b7 A1 class绑定 第二种 正常绑定   -->
    <!-- <style>
      .active{
        color: green;
      }
    </style>
    <div id="yz-hello" >
        <h2 class="active" >{{mag}}</h2>
    </div> -->


    
    <!-- b7 A2 class绑定 第三种 存方法或计算属性绑定   -->
    <!-- <style>
      .active{
        color: green;
      }
      .active2{
        color: red;
      }
    </style>
    <div id="yz-hello" >
        <h2 :class="getclass()" >{{mag}}</h2>
        <h2 :class="getclasss" >{{mag}}</h2>
    </div> -->






    <!-- b8 class 样式类 决定是否使用 -->
    <!-- 对象绑定法 -->
    <!-- <h1  id="yz-hello"  v-bind:class="{blue:isActive}">hello，源栈</h1> -->
    <!-- vm.isActive = false -->
    <!-- 资料1 多个类  对象中 ，可以传多个类名 ，类值： 在渲染设置参数，能用还是不能用 "{blue:isActive, italic:needEmphasis}" 这些对象包裹键值对的方法 也叫对象语法 -->
    <!-- 资料2 对象和数组混用 数组是装多个类的 [bg,{italic:needEmphasis}] 一 区别 ：个用原生类名 一个不用原生类名  -->
    <!-- 资料3 数据操作 b站老师 类名和布尔值，放到方法里绑定方法返回值，或者放入计算属性  -->













    <!-- b9 style 样式 绑定 -->
    <!-- 行内绑定类 -->
    <!-- 行内绑定背景色 背景色值 渲染函数控制 -->
    <!-- <h1 id="yz-hello" v-bind:style="{fontStyle:fs, backgroundColor:bg}">杨嘉栋</h1> -->
    <!-- 写法  -->
    <!--  v-bind:style="{color:color}  -->
    <!-- 属性名驼峰标识写法 -->
    <!-- 当做变量使用 -->
    <!--  v-bind:style="{fontStyle:fs, backgroundColor:bg}  -->
    <!-- 属性名短横杠写法 -->
     <!--  v-bind:style="{font-style:fs, background-color:bg}  -->
     <!-- 行内写值 -->
     <!-- 当做字符串使用 -->
    <!-- <h1 id="yz-hello" :style="{fontSize:'100px'}">杨嘉栋</h1> -->
    <!-- 当做变量使用分支 data变量设置数字 拼接处理 -->
    <!-- <h4 id="yz-hello" v-bind:style="{fontSize: szi + 'px'}">杨嘉栋</h4> -->
    <!-- 数据存入data去 方法返回样式调用 -->
    <!-- <h4 id="yz-hello" v-bind:style="existstyle()">杨嘉栋</h4> -->
    <!-- 数组语法 绑定style -->
    <!-- <h4 id="yz-hello" v-bind:style="[baksty,bakbcak]">杨嘉栋 数组语法   style绑定 </h4> -->
     
   


    


    


    
    
    










    <!-- b19 vue 钩子函数生命周期  -->
    <!-- 生命周期方法 从生到死不同阶段调用不同方法  -->
    <!-- <h1 id="yz-hello">
        {{greet}}
    </h1> -->
    <!-- 钩子函数不按照顺序执行 只是一种声明 该谁先就谁  -->



    <!--b20 响应式原理  -->
    <!-- Vue 将遍历此对象所有的 property，并使用 Object.defineProperty 把这些 property 属性和值  全部转为 getter/setter -->
    <!-- 在 property 被访问和修改时通知变更。 set变更重新渲染虚拟dom节点  -->
    <!-- vue 拿到数据 绑定监察响应方法 如果修改了属性 调用监察响应中的更改方法 重新渲染  -->



    <!-- b21 计算属性  -->
    <!-- 参考资料 油管 -->
    <!-- <button v-on:click="a++">Add to </button>
    <p>Age + A = {{addToA}} </p>
    //     computed:{
    //         addToA:function(){
    //         console.log('adda');
    //         return this.a + this.age;
    //         }, -->
    
    <!-- <h1 id="yz-hello">{{summary}}</h1> -->





    <!-- b22 列表筛选 for if   -->
    <!-- 用计算属性筛选 -->
    <!-- 参考资料 油管 -->
    <!-- <div  id="yz-hello" >
        <h1 v-for = "(s,i) in  filtered" >
            <p >{{s}}</p>
        </h1>
   
    </div> -->
    <!-- 两道for过滤出来的数组元素  -->


    <!--b23 计算属性 set   -->
    <!-- 当suanmmary属性值被改变时候，触发set方法  -->
    <!-- <div  id="yz-hello" >
        {{summary}}
    </div> -->

    <!--b23-A1 计算属性简单使用 字符串拼接  -->
    <!-- <div  id="yz-hello" >
        <p>{{summary}}</p>
    </div> -->


    <!--b23-A2 计算属性复杂使用  -->
    <!-- <div  id="yz-hello" >
        <p>{{sumNumber}}</p>
    </div> -->

    <!--//b23-A3  计算属性 缓存效果代码展示  -->
    <!-- <div  id="yz-hello" >
        <p>{{summary}}</p>
        <p>{{summary}}</p>
        <p>{{summary}}</p>

        <p>{{msumary()}}</p>
        <p>{{msumary()}}</p>
        <p>{{msumary()}}</p>
    </div> -->




    <!--b24 计算属性 set   -->
    <!--// 每次改变一次data的随意 a属性一个值 ，mathods 方法就会重新运行一遍，其中的 b 属性值计算 c属性值 d属性值 进行计算 ，重新渲染一遍  -->



    <!--b25 监控钩子函数 watch   -->
    <!-- 只监控数据是否发生变化 -->
    <!-- <div  id="yz-hello" >
        {{body}}
    </div> -->
    <!-- 在watch使用了data数据  运行时 不会触发 watch ，修改data数据时 触发watch  -->



    <!-- b26  methods构造函数-->
    <!-- <div  id="yz-hello" >
        {{summary()}}
    </div> -->



    <!-- b27 表单 input 绑定 -->
    <!-- 参考资料 -->
    <!-- 双向绑定 输入查看效果 -->
    <!-- <input type="text" v-model="age" >
    <span>{{age}}</span> -->
    <!-- 双向绑定 绑定值为对象其中一个值 -->
    <!-- <div  id="yz-hello" >
        <input type="text" v-model="body.full" value="一起帮" />
        <span>{{body.full}}</span>
    </div> -->


    <!--  b28 表单 radio 单选框 绑定   -->
    <!-- <div  id="yz-hello" >
        <label v-for="s of students">
            <input  type="radio" v-bind:value="s.id" v-model="selectedId" />{{s.name}}
        </label>
    </div> -->




    <!--  b29 表单 checkbox 复选框 绑定   -->
    <!-- 单个 -->
    <!-- <div  id="yz-hello" >
        <input type="checkbox" v-model="remember" />记住我
    </div> -->


    <!--  b30 表单 checkbox复选框 绑定   -->
    <!--多个 复选框 -->
    <!-- <div  id="yz-hello" >
        <input type="checkbox" value="1" v-model="students" />夏康平
        <input type="checkbox" value="12" v-model="students" />陈国栋
        <input type="checkbox" value="6" v-model="students" />韩佳宝
    </div> -->



    <!--  b31 表单checkbox 复选框 绑定   -->
    <!--循环绑定复选框 -->
    <!-- v-model="enrolleds" v-model="s.enrolled"   -->
    <!-- <div  id="yz-hello" >
        <label v-for="s of students">
            <input  type="checkbox" :value="s.id" v-model="enrolleds"    />{{s.name}}
        </label>
    </div> -->




    <!--  b32 表单 select 下拉列表 绑定   -->
    <!-- <div  id="yz-hello" >
        <select v-model="selectedId"> 
            <option value="0" >---</option>
            <option v-for="s of students" :value="s.id" >{{s.name}}</option>
        </select>
    </div> -->
    <!--注意v-model放置在select元素中，添加mutiple变成多选-->
    <!-- 额外添加一个option： 作用 -->




  

  




    

   



    <!-- 40 vue  dom元素操作 -->
    <!-- 需求 消除浏览器默认提示 -->
    <!-- 渲染完成后，执行docment元素  -->
        <!-- <style>
        .tooltip {
        background-color: cadetblue;
        position: relative;
        right: 65px;
        bottom: 20px;
        }
    </style> -->

    <!-- <p style="padding-top: 50px;" id="yz-hello" >   
        <span id="slagon" v-on:mouseover="show" v-on:mouseout="hide"  v-bind:title="showTitle"  >源栈欢迎您</span>
        id 属于docment 方式操作元素 获取元素 
        <span ref="slagon" v-on:mouseover="show" v-on:mouseout="hide"  v-bind:title="showTitle"  >源栈欢迎您</span>
        $refs Vue还提供了一个快捷的定位某DOM元素的方式：
        <span v-if="shown" class="tooltip">{{showTitle}}</span>
    </p> -->
    
    <script>
        // 解释 
        // 先跑模板渲染函数出一遍虚拟dom，在补丁阶段触发在渲染函数跑一遍，两边dom对比
        // 渲染第1遍的时候 docment，没有执行

        // a=1 模板 虚拟dom1 / a=2 补丁函数 虚拟dom2 
        // domcment 执行时机
        // 在补丁函数虚拟产生 dom2 ，数据没有渲染前 a=1 dom不执行，所以渲染过程完成前 a=2 ，dom也执行过了，所以提示也就出来了，
        // 因此
        // 执行在补丁函数虚拟产生 dom2 ，数据渲染完成后， a=2 ，在执行docment为空 
    </script>
                

    <!-- 41 vue  dom元素操作 -->
    <!-- 需求  铃铛 文本闪烁变换颜色 -->
    <!-- 渲染完成后，执行docment元素  -->
    <!-- <div id="yz-hello">
        <div id="bell"  v-bind:style="{color:color}">bell</div>
    </div> -->
    <script>
    // load 加载 /unload 离开等于页面跳转触发 
    // 码农场景
    //需要把代码写在html文件中，但是要等到dom元素加载完成，在执行事件绑定代码 

    // 立即执行 load是在div元素用不了的，要用挂载钩子函数 
    </script>



    <!-- 42 vue  form表单 -->
    <!-- 表单内容验证  -->
    <!-- 表单内容阻止提交 错误信息和验证是两码事 -->
    <!-- <form  v-on:submit="checkAll" novalidate="true" id="yz-hello">
        <input v-on:change="require" v-model="sname" >
        <span v-if="error">{{error}}</span>
        <button type="submit">提交</button>
    </form> -->

    <script>
        // novalidate html5 自带验证 进行关闭 
        // change 改变事件 输入框内容改变时候 
        // require 要求方法 验证输入内容 
        // model bind 都能绑定 ，medel是双向绑定 
        // model js中的vue实例中 的data与其渲染的dom元素上的内容保持一致，两者无论谁被改变，另一方也会相应的更新为相同的数据
        // bind 元素的属性中绑定 data中属性
        // v-if  A：直接绑定vue实例属性 设定真假 ，B：行内表达式 i 直接进行判断

        // submint 提交 checkAll 
    </script>


    <!-- 43 vue  form表单 -->
    <!-- 表单多个内容验证  -->
    <!-- <form  v-on:submit="checkAll" novalidate="true" id="yz-hello">
        <p>
            <label for="">用户名</label>
            <input v-on:blur="require" v-model="sname" >
            <span v-if="error.sname">* 用户名需要填写</span>
        </p>

        <p>
            <label for="">密码</label>
            <input v-on:blur="require" v-model="password" >
            <span v-if="error.password">* 密码需要填写</span>
        </p>

        <p>
            <label for="">确认密码</label>
            <input v-on:blur="require" v-model="confirmPassword" >
            <span v-if="error.confirmPassword">* 确认密码要填写</span>
        </p>

        <p>
            <label for="">确认密码</label>
            <input v-on:blur="sameWith" v-model="confirmPassword" >
            <span v-if="error.confirmPassword">* 确认密码要一致</span>
        </p>


        <button type="submit">提交</button>
    </form> -->

    <!-- 注意 这里边有两个 确认密码的运算 ，用的时候记得区分禁用掉一个  -->
    <!-- blur 失焦判断 -->





























    <!-- 使用展示  -->
    <!-- <h1 v id="yz-hello">{{greet}}</h1> -->
    <!-- vue 中 html 成为模板 -->

    <!-- <script>
        var vm = new Vue({
    el: "#yz-hello", 
    data: {
        greet: "Hello, 源栈!！"  
    }
    })
    </script> -->

    <script>
     //#代表id 元素选择 
     //确定greet的内容
    // vm 实例对象，也叫视图对象 
    // vue的构造函数，中 el 和 data 属性， this上下文， 自动绑定新对象 指向h1，
    // 也称之为渲染过程 

    // 为什么不用 直接写标签里面？
    // 因为前后端数据分离理念 ，展示内容从后端拿取 
    </script>



    <!-- 顺序 -->
    <!-- 先模板后渲染 -->

</body>
<script   src="/vuejs-playlist/v.js"> </script>
</html>